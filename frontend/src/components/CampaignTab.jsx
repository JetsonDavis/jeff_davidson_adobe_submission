import { useState, useEffect, useRef } from 'react';
import { RefreshCw, Loader2, Trash2 } from 'lucide-react';
import BriefUpload from './BriefUpload';
import AssetUpload from './AssetUpload';
import AssetThumbnail from './AssetThumbnail';
import IdeaCard from './IdeaCard';
import ApprovalQueue from './ApprovalQueue';

export default function CampaignTab({ tabId }) {
  const [brief, setBrief] = useState(null);
  const [assets, setAssets] = useState([]);
  const [ideas, setIdeas] = useState([]);
  const [creatives, setCreatives] = useState([]);
  const [loading, setLoading] = useState(false);
  const [isBriefValid, setIsBriefValid] = useState(false);
  const [isCreatingBrief, setIsCreatingBrief] = useState(false);
  const [generationProgress, setGenerationProgress] = useState({}); // Track progress per idea
  const briefSubmitRef = useRef(null);

  // Fetch assets when component mounts and clean up auto-generated ones
  useEffect(() => {
    const initializeAssets = async () => {
      // Clean up auto-generated assets from previous session
      await cleanupAutoGeneratedAssets();
      // Then fetch remaining assets
      await fetchAssets();
    };
    initializeAssets();
  }, []);

  const cleanupAutoGeneratedAssets = async () => {
    try {
      // Fetch all assets
      const response = await fetch('http://localhost:8002/assets');
      const allAssets = await response.json();
      
      // Delete all auto-generated assets
      const autoGenerated = allAssets.filter(asset => asset.auto_generated);
      for (const asset of autoGenerated) {
        await fetch(`http://localhost:8002/assets/${asset.id}`, {
          method: 'DELETE'
        });
      }
      console.log(`Cleaned up ${autoGenerated.length} auto-generated assets`);
    } catch (err) {
      console.error('Failed to cleanup auto-generated assets:', err);
    }
  };

  const fetchAssets = async () => {
    try {
      const response = await fetch('http://localhost:8002/assets');
      const data = await response.json();
      setAssets(data);
    } catch (err) {
      console.error('Failed to fetch assets:', err);
    }
  };

  const fetchIdeas = async (briefId) => {
    console.log('Fetching ideas for brief:', briefId);
    try {
      const response = await fetch(`http://localhost:8002/briefs/${briefId}`);
      const data = await response.json();
      console.log('Fetched brief data:', data);
      console.log('Ideas:', data.ideas);
      setIdeas(data.ideas || []);
    } catch (err) {
      console.error('Failed to fetch ideas:', err);
    }
  };

  const fetchCreatives = async () => {
    try {
      const response = await fetch('http://localhost:8002/creatives');
      const data = await response.json();
      console.log('Fetched creatives count:', data.length);
      console.log('Fetched creatives:', data);
      setCreatives(data);
    } catch (err) {
      console.error('Failed to fetch creatives:', err);
    }
  };

  const handleBriefCreated = async (newBrief) => {
    setBrief(newBrief);
    // Refresh assets to show any auto-generated brand/product images
    await fetchAssets();
    setIsCreatingBrief(false);
  };

  const handleCreateBriefClick = async (e) => {
    setIsCreatingBrief(true);
    try {
      await briefSubmitRef.current?.submit(e);
    } catch (err) {
      setIsCreatingBrief(false);
      console.error('Error creating brief:', err);
    }
  };

  const handleExecuteBrief = async () => {
    console.log('Execute brief clicked, brief:', brief);
    setLoading(true);
    setCreatives([]); // Clear approval queue
    
    try {
      const response = await fetch(`http://localhost:8002/briefs/${brief.id}/execute`, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error('Failed to execute brief');
      }
      
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) {
          setLoading(false);
          break;
        }
        
        // Decode the chunk and add to buffer
        buffer += decoder.decode(value, { stream: true });
        
        // Process complete messages (SSE format: "data: {...}\n\n")
        const messages = buffer.split('\n\n');
        buffer = messages.pop() || ''; // Keep incomplete message in buffer
        
        for (const message of messages) {
          if (message.startsWith('data: ')) {
            try {
              const data = JSON.parse(message.substring(6));
              console.log('SSE message:', data);
              
              if (data.type === 'init') {
                // Create placeholder idea cards
                const placeholders = [];
                for (const region of data.regions) {
                  for (const demographic of data.demographics) {
                    placeholders.push({
                      id: `placeholder-${region}-${demographic}`,
                      region,
                      demographic,
                      content: null, // null indicates loading
                      generation_count: 1,
                      isPlaceholder: true
                    });
                  }
                }
                setIdeas(placeholders);
              } else if (data.type === 'idea') {
                // Update the specific placeholder with actual idea
                setIdeas(prevIdeas => 
                  prevIdeas.map(idea => 
                    idea.region === data.region && idea.demographic === data.demographic
                      ? { ...data, isPlaceholder: false }
                      : idea
                  )
                );
              } else if (data.type === 'error') {
                // Handle individual idea error
                console.error(`Error generating idea for ${data.region}/${data.demographic}:`, data.error);
                setIdeas(prevIdeas => 
                  prevIdeas.map(idea => 
                    idea.region === data.region && idea.demographic === data.demographic
                      ? { ...idea, content: `Error: ${data.error}`, isPlaceholder: false, hasError: true }
                      : idea
                  )
                );
              } else if (data.type === 'complete') {
                console.log('All ideas generated successfully');
                setLoading(false);
              } else if (data.type === 'fatal_error') {
                console.error('Fatal error:', data.error);
                alert(`Error: ${data.error}`);
                setLoading(false);
              }
            } catch (parseError) {
              console.error('Error parsing message:', parseError, message);
            }
          }
        }
      }
      
    } catch (err) {
      console.error('Failed to execute brief:', err);
      alert(`Error: ${err.message}`);
      setLoading(false);
    }
  };

  const handleRegenerateIdea = (updatedIdea) => {
    setIdeas(ideas.map(idea => 
      idea.id === updatedIdea.id ? updatedIdea : idea
    ));
  };

  const handleGenerateCreative = async (newCreatives) => {
    console.log('handleGenerateCreative called with:', newCreatives);
    console.log('Fetching creatives...');
    await fetchCreatives();
    console.log('Creatives fetched, current count:', creatives.length);
  };

  const handleGenerateAllCreatives = async () => {
    console.log('Generating all creatives for', ideas.length, 'ideas');
    setLoading(true);
    
    // Initialize progress for all ideas
    const initialProgress = {};
    ideas.forEach(idea => {
      initialProgress[idea.id] = {
        '16:9': { loading: true, data: null },
        '9:16': { loading: true, data: null },
        '1:1': { loading: true, data: null }
      };
    });
    setGenerationProgress(initialProgress);
    
    // Ensure minimum 2 seconds of spinner visibility
    const minDelay = new Promise(resolve => setTimeout(resolve, 2000));
    
    try {
      // Generate creatives for all ideas
      for (const idea of ideas) {
        console.log('Generating creative for idea:', idea.id);
        
        // Stream creatives and update UI as they arrive
        const response = await fetch(`http://localhost:8002/ideas/${idea.id}/generate-creative`, {
          method: 'POST',
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            console.log(`‚úÖ Completed generating creatives for idea: ${idea.id}`);
            break;
          }
          
          // Decode the chunk and add to buffer
          buffer += decoder.decode(value, { stream: true });
          
          // Process complete SSE messages (separated by \n\n)
          const messages = buffer.split('\n\n');
          buffer = messages.pop() || ''; // Keep incomplete message in buffer
          
          for (const message of messages) {
            if (!message.trim()) continue;
            
            // Parse SSE format: "event: type\ndata: json"
            const lines = message.split('\n');
            let eventType = 'message';
            let eventData = '';
            
            for (const line of lines) {
              if (line.startsWith('event: ')) {
                eventType = line.substring(7).trim();
              } else if (line.startsWith('data: ')) {
                eventData = line.substring(6).trim();
              }
            }
            
            if (!eventData) continue;
            
            try {
              const data = JSON.parse(eventData);
              
              if (eventType === 'creative') {
                console.log(`‚úÖ Creative received: ${data.aspect_ratio}`, data);
                console.log(`Updating progress for idea ${idea.id}, aspect ${data.aspect_ratio}`);
                
                // Update progress for this specific creative
                setGenerationProgress(prev => {
                  const updated = {
                    ...prev,
                    [idea.id]: {
                      ...prev[idea.id],
                      [data.aspect_ratio]: { loading: false, data }
                    }
                  };
                  console.log('Updated progress state:', updated);
                  return updated;
                });
                
                // Immediately fetch and update creatives
                await fetchCreatives();
              }
            } catch (parseError) {
              console.error('‚ùå Failed to parse SSE data:', eventData, parseError);
            }
          }
        }
      }
      
      // Final fetch to ensure all creatives are displayed
      console.log('Fetching all creatives after generation');
      await fetchCreatives();
      
      // Wait for minimum delay
      await minDelay;
    } catch (err) {
      console.error('Failed to generate all creatives:', err);
      await minDelay; // Still wait even on error
      alert('Error generating creatives. Check console for details.');
    } finally {
      setLoading(false);
      setGenerationProgress({}); // Clear progress
    }
  };

  const handleAssetUploaded = (newAsset) => {
    setAssets([...assets, newAsset]);
  };

  const handleAssetDeleted = (assetId) => {
    setAssets(assets.filter(a => a.id !== assetId));
  };

  const handleAssetRegenerated = (updatedAsset) => {
    setAssets(assets.map(a => a.id === updatedAsset.id ? updatedAsset : a));
  };

  const handleIdeaDeleted = (ideaId) => {
    setIdeas(ideas.filter(i => i.id !== ideaId));
  };

  const handleDeleteAllCreatives = async () => {
    if (!confirm(`Delete all ${creatives.length} creatives? This will remove all creative files from the filesystem.`)) {
      return;
    }

    try {
      console.log(`Deleting ${creatives.length} creatives...`);
      
      // Delete all creatives
      const deletePromises = creatives.map(creative =>
        fetch(`http://localhost:8002/creatives/${creative.id}`, {
          method: 'DELETE',
        })
      );

      await Promise.all(deletePromises);
      console.log('‚úÖ All creatives deleted');
      
      // Refresh creatives list
      await fetchCreatives();
    } catch (err) {
      console.error('Failed to delete all creatives:', err);
      alert('Failed to delete some creatives. Check console for details.');
    }
  };

  return (
    <div className="h-full overflow-y-auto">
      <div className="max-w-7xl mx-auto p-6 space-y-6">
        {/* Brief Section */}
        <section>
          <h2 className="text-2xl font-bold mb-4">Campaign Brief</h2>
          <BriefUpload 
            onBriefCreated={handleBriefCreated} 
            onSubmitRef={briefSubmitRef}
            onValidityChange={setIsBriefValid}
          />
        </section>

        {/* Assets Section */}
        <section>
          <h2 className="text-2xl font-bold mb-1">Brand & Product Assets</h2>
          <p className="text-sm text-gray-600 mb-4">Multiple assets can be added. If no assets are uploaded, one will be created for you.</p>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Brand Assets */}
            <div>
              <AssetUpload assetType="brand" onAssetUploaded={handleAssetUploaded} />
              <div className="grid grid-cols-3 gap-3 mt-3">
                {assets.filter(a => a.asset_type === 'brand').map(asset => (
                  <AssetThumbnail 
                    key={asset.id} 
                    asset={asset}
                    onDelete={handleAssetDeleted}
                    onRegenerate={handleAssetRegenerated}
                  />
                ))}
              </div>
            </div>
            
            {/* Product Assets */}
            <div>
              <AssetUpload assetType="product" onAssetUploaded={handleAssetUploaded} />
              <div className="grid grid-cols-3 gap-3 mt-3">
                {assets.filter(a => a.asset_type === 'product').map(asset => (
                  <AssetThumbnail 
                    key={asset.id} 
                    asset={asset}
                    onDelete={handleAssetDeleted}
                    onRegenerate={handleAssetRegenerated}
                  />
                ))}
              </div>
            </div>
          </div>
        </section>

        {/* Create Brief Button */}
        {!brief && (
          <section>
            <button
              onClick={handleCreateBriefClick}
              disabled={!isBriefValid || isCreatingBrief}
              className="w-full bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed font-semibold flex items-center justify-center gap-2"
            >
              {isCreatingBrief && <RefreshCw className="w-5 h-5 animate-spin" />}
              {isCreatingBrief ? 'Creating Brief...' : 'Create Brief'}
            </button>
          </section>
        )}

        {/* Execute Brief Section */}
        {brief && (
          <section>
            <div className="p-4 bg-white border rounded-lg">
              <div className="flex justify-between items-start mb-2">
                <div className="flex-1">
                  <h3 className="font-semibold">Campaign: {brief.campaign_message}</h3>
                  <p className="text-gray-600 text-sm mt-1">{brief.content}</p>
                </div>
                <button
                  onClick={handleExecuteBrief}
                  disabled={loading}
                  className="ml-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
                >
                  {loading ? 'Generating...' : 'Execute Brief'}
                </button>
              </div>
              <div className="flex gap-2 mt-2 text-xs">
                <span className="bg-blue-100 text-blue-800 px-2 py-1 rounded">
                  Regions: {(typeof brief.regions === 'string' ? JSON.parse(brief.regions) : brief.regions).join(', ')}
                </span>
                <span className="bg-green-100 text-green-800 px-2 py-1 rounded">
                  Demographics: {(typeof brief.demographics === 'string' ? JSON.parse(brief.demographics) : brief.demographics).join(', ')}
                </span>
              </div>
            </div>
          </section>
        )}

        {/* Ideas Section */}
        {ideas.length > 0 && (
          <section>
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-2xl font-bold">Creative Ideas</h2>
              <button
                onClick={handleGenerateAllCreatives}
                disabled={loading}
                className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
              >
                {loading && <RefreshCw className="w-4 h-4 animate-spin" />}
                {loading ? 'Generating...' : 'Generate All'}
              </button>
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {ideas.map(idea => (
                <IdeaCard 
                  key={idea.id} 
                  idea={idea}
                  onRegenerate={handleRegenerateIdea}
                  onGenerateCreative={handleGenerateCreative}
                  onDelete={handleIdeaDeleted}
                />
              ))}
            </div>
          </section>
        )}

        {/* Approval Queue Section */}
        {creatives.length > 0 || Object.keys(generationProgress).length > 0 ? (
          <section>
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-2xl font-bold">
                {Object.keys(generationProgress).length > 0 
                  ? 'üé® Generating Creatives...' 
                  : `Approval Queue (${creatives.length} creatives)`}
              </h2>
              {creatives.length > 0 && (
                <button
                  onClick={handleDeleteAllCreatives}
                  className="flex items-center gap-2 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors"
                >
                  <Trash2 className="w-4 h-4" />
                  Delete All
                </button>
              )}
            </div>
            
            {/* Show EITHER progress grid OR approval queue, not both */}
            {Object.keys(generationProgress).length > 0 ? (
              // Generation Progress Grid (while generating)
              <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {ideas.map(idea => {
                    const progress = generationProgress[idea.id];
                    if (!progress) return null;
                    
                    return (
                      <div key={idea.id} className="bg-white rounded-lg p-3 border border-blue-200">
                        <div className="flex gap-1 mb-2">
                          <span className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">{idea.region}</span>
                          <span className="text-xs bg-green-100 text-green-800 px-2 py-1 rounded">{idea.demographic}</span>
                        </div>
                        <div className="grid grid-cols-3 gap-2">
                          {['16:9', '9:16', '1:1'].map(aspectRatio => {
                            const aspectProgress = progress[aspectRatio];
                            
                            return (
                              <div key={aspectRatio} className="text-center">
                                <div className="text-xs font-semibold text-purple-800 bg-purple-100 px-1 py-0.5 rounded mb-1">
                                  {aspectRatio}
                                </div>
                                {aspectProgress.loading ? (
                                  <div className="bg-gray-200 rounded h-16 flex items-center justify-center">
                                    <RefreshCw className="w-4 h-4 text-blue-500 animate-spin" />
                                  </div>
                                ) : (
                                  <div className="bg-green-100 rounded h-16 overflow-hidden flex items-center justify-center">
                                    <img
                                      src={`http://localhost:8002/${aspectProgress.data.file_path}?t=${Date.now()}`}
                                      alt={aspectRatio}
                                      className="max-h-full max-w-full object-contain"
                                    />
                                  </div>
                                )}
                                <p className="text-xs text-gray-600 mt-1">
                                  {aspectProgress.loading ? '‚è≥' : '‚úì'}
                                </p>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            ) : (
              // Approval Queue (after generation complete)
              creatives.length > 0 && (
                <ApprovalQueue creatives={creatives} onCreativeUpdate={fetchCreatives} />
              )
            )}
          </section>
        ) : (
          <section>
            <div className="text-center py-8 text-gray-400 border-2 border-dashed rounded-lg">
              No creatives yet. Click "Generate Creative" on an idea to create visual assets.
            </div>
          </section>
        )}
      </div>
    </div>
  );
}
