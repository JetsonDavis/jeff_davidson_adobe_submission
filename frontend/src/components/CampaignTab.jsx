import { useState, useEffect, useRef } from 'react';
import { RefreshCw } from 'lucide-react';
import BriefUpload from './BriefUpload';
import AssetUpload from './AssetUpload';
import AssetThumbnail from './AssetThumbnail';
import IdeaCard from './IdeaCard';
import ApprovalQueue from './ApprovalQueue';

export default function CampaignTab({ tabId }) {
  const [brief, setBrief] = useState(null);
  const [assets, setAssets] = useState([]);
  const [ideas, setIdeas] = useState([]);
  const [creatives, setCreatives] = useState([]);
  const [loading, setLoading] = useState(false);
  const [isBriefValid, setIsBriefValid] = useState(false);
  const [isCreatingBrief, setIsCreatingBrief] = useState(false);
  const briefSubmitRef = useRef(null);

  // Fetch assets when component mounts and clean up auto-generated ones
  useEffect(() => {
    const initializeAssets = async () => {
      // Clean up auto-generated assets from previous session
      await cleanupAutoGeneratedAssets();
      // Then fetch remaining assets
      await fetchAssets();
    };
    initializeAssets();
  }, []);

  const cleanupAutoGeneratedAssets = async () => {
    try {
      // Fetch all assets
      const response = await fetch('http://localhost:8002/assets');
      const allAssets = await response.json();
      
      // Delete all auto-generated assets
      const autoGenerated = allAssets.filter(asset => asset.auto_generated);
      for (const asset of autoGenerated) {
        await fetch(`http://localhost:8002/assets/${asset.id}`, {
          method: 'DELETE'
        });
      }
      console.log(`Cleaned up ${autoGenerated.length} auto-generated assets`);
    } catch (err) {
      console.error('Failed to cleanup auto-generated assets:', err);
    }
  };

  const fetchAssets = async () => {
    try {
      const response = await fetch('http://localhost:8002/assets');
      const data = await response.json();
      setAssets(data);
    } catch (err) {
      console.error('Failed to fetch assets:', err);
    }
  };

  const fetchIdeas = async (briefId) => {
    console.log('Fetching ideas for brief:', briefId);
    try {
      const response = await fetch(`http://localhost:8002/briefs/${briefId}`);
      const data = await response.json();
      console.log('Fetched brief data:', data);
      console.log('Ideas:', data.ideas);
      setIdeas(data.ideas || []);
    } catch (err) {
      console.error('Failed to fetch ideas:', err);
    }
  };

  const fetchCreatives = async () => {
    try {
      const response = await fetch('http://localhost:8002/creatives');
      const data = await response.json();
      console.log('Fetched creatives count:', data.length);
      console.log('Fetched creatives:', data);
      setCreatives(data);
    } catch (err) {
      console.error('Failed to fetch creatives:', err);
    }
  };

  const handleBriefCreated = async (newBrief) => {
    setBrief(newBrief);
    // Refresh assets to show any auto-generated brand/product images
    await fetchAssets();
    setIsCreatingBrief(false);
  };

  const handleCreateBriefClick = async (e) => {
    setIsCreatingBrief(true);
    try {
      await briefSubmitRef.current?.submit(e);
    } catch (err) {
      setIsCreatingBrief(false);
      console.error('Error creating brief:', err);
    }
  };

  const handleExecuteBrief = async () => {
    console.log('Execute brief clicked, brief:', brief);
    setLoading(true);
    setCreatives([]); // Clear approval queue
    
    try {
      const response = await fetch(`http://localhost:8002/briefs/${brief.id}/execute`, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error('Failed to execute brief');
      }
      
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) {
          setLoading(false);
          break;
        }
        
        // Decode the chunk and add to buffer
        buffer += decoder.decode(value, { stream: true });
        
        // Process complete messages (SSE format: "data: {...}\n\n")
        const messages = buffer.split('\n\n');
        buffer = messages.pop() || ''; // Keep incomplete message in buffer
        
        for (const message of messages) {
          if (message.startsWith('data: ')) {
            try {
              const data = JSON.parse(message.substring(6));
              console.log('SSE message:', data);
              
              if (data.type === 'init') {
                // Create placeholder idea cards
                const placeholders = [];
                for (const region of data.regions) {
                  for (const demographic of data.demographics) {
                    placeholders.push({
                      id: `placeholder-${region}-${demographic}`,
                      region,
                      demographic,
                      content: null, // null indicates loading
                      generation_count: 1,
                      isPlaceholder: true
                    });
                  }
                }
                setIdeas(placeholders);
              } else if (data.type === 'idea') {
                // Update the specific placeholder with actual idea
                setIdeas(prevIdeas => 
                  prevIdeas.map(idea => 
                    idea.region === data.region && idea.demographic === data.demographic
                      ? { ...data, isPlaceholder: false }
                      : idea
                  )
                );
              } else if (data.type === 'error') {
                // Handle individual idea error
                console.error(`Error generating idea for ${data.region}/${data.demographic}:`, data.error);
                setIdeas(prevIdeas => 
                  prevIdeas.map(idea => 
                    idea.region === data.region && idea.demographic === data.demographic
                      ? { ...idea, content: `Error: ${data.error}`, isPlaceholder: false, hasError: true }
                      : idea
                  )
                );
              } else if (data.type === 'complete') {
                console.log('All ideas generated successfully');
                setLoading(false);
              } else if (data.type === 'fatal_error') {
                console.error('Fatal error:', data.error);
                alert(`Error: ${data.error}`);
                setLoading(false);
              }
            } catch (parseError) {
              console.error('Error parsing message:', parseError, message);
            }
          }
        }
      }
      
    } catch (err) {
      console.error('Failed to execute brief:', err);
      alert(`Error: ${err.message}`);
      setLoading(false);
    }
  };

  const handleRegenerateIdea = (updatedIdea) => {
    setIdeas(ideas.map(idea => 
      idea.id === updatedIdea.id ? updatedIdea : idea
    ));
  };

  const handleGenerateCreative = async (newCreatives) => {
    console.log('handleGenerateCreative called with:', newCreatives);
    console.log('Fetching creatives...');
    await fetchCreatives();
    console.log('Creatives fetched, current count:', creatives.length);
  };

  const handleGenerateAllCreatives = async () => {
    console.log('Generating all creatives for', ideas.length, 'ideas');
    setLoading(true);
    
    // Ensure minimum 2 seconds of spinner visibility
    const minDelay = new Promise(resolve => setTimeout(resolve, 2000));
    
    try {
      // Generate creatives for all ideas
      for (const idea of ideas) {
        console.log('Generating creative for idea:', idea.id);
        const response = await fetch(`http://localhost:8002/ideas/${idea.id}/generate-creative`, {
          method: 'POST',
        });
        const result = await response.json();
        console.log('Generated creative result:', result);
      }
      // Fetch all creatives after generation
      console.log('Fetching all creatives after generation');
      await fetchCreatives();
      
      // Wait for minimum delay
      await minDelay;
    } catch (err) {
      console.error('Failed to generate all creatives:', err);
      await minDelay; // Still wait even on error
      alert('Error generating creatives. Check console for details.');
    } finally {
      setLoading(false);
    }
  };

  const handleAssetUploaded = (newAsset) => {
    setAssets([...assets, newAsset]);
  };

  const handleAssetDeleted = (assetId) => {
    setAssets(assets.filter(a => a.id !== assetId));
  };

  const handleAssetRegenerated = (updatedAsset) => {
    setAssets(assets.map(a => a.id === updatedAsset.id ? updatedAsset : a));
  };

  const handleIdeaDeleted = (ideaId) => {
    setIdeas(ideas.filter(i => i.id !== ideaId));
  };

  return (
    <div className="h-full overflow-y-auto">
      <div className="max-w-7xl mx-auto p-6 space-y-6">
        {/* Brief Section */}
        <section>
          <h2 className="text-2xl font-bold mb-4">Campaign Brief</h2>
          <BriefUpload 
            onBriefCreated={handleBriefCreated} 
            onSubmitRef={briefSubmitRef}
            onValidityChange={setIsBriefValid}
          />
        </section>

        {/* Assets Section */}
        <section>
          <h2 className="text-2xl font-bold mb-1">Brand & Product Assets</h2>
          <p className="text-sm text-gray-600 mb-4">Multiple assets can be added. If no assets are uploaded, one will be created for you.</p>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Brand Assets */}
            <div>
              <AssetUpload assetType="brand" onAssetUploaded={handleAssetUploaded} />
              <div className="grid grid-cols-3 gap-3 mt-3">
                {assets.filter(a => a.asset_type === 'brand').map(asset => (
                  <AssetThumbnail 
                    key={asset.id} 
                    asset={asset}
                    onDelete={handleAssetDeleted}
                    onRegenerate={handleAssetRegenerated}
                  />
                ))}
              </div>
            </div>
            
            {/* Product Assets */}
            <div>
              <AssetUpload assetType="product" onAssetUploaded={handleAssetUploaded} />
              <div className="grid grid-cols-3 gap-3 mt-3">
                {assets.filter(a => a.asset_type === 'product').map(asset => (
                  <AssetThumbnail 
                    key={asset.id} 
                    asset={asset}
                    onDelete={handleAssetDeleted}
                    onRegenerate={handleAssetRegenerated}
                  />
                ))}
              </div>
            </div>
          </div>
        </section>

        {/* Create Brief Button */}
        {!brief && (
          <section>
            <button
              onClick={handleCreateBriefClick}
              disabled={!isBriefValid || isCreatingBrief}
              className="w-full bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed font-semibold flex items-center justify-center gap-2"
            >
              {isCreatingBrief && <RefreshCw className="w-5 h-5 animate-spin" />}
              {isCreatingBrief ? 'Creating Brief...' : 'Create Brief'}
            </button>
          </section>
        )}

        {/* Execute Brief Section */}
        {brief && (
          <section>
            <div className="p-4 bg-white border rounded-lg">
              <div className="flex justify-between items-start mb-2">
                <div className="flex-1">
                  <h3 className="font-semibold">Campaign: {brief.campaign_message}</h3>
                  <p className="text-gray-600 text-sm mt-1">{brief.content}</p>
                </div>
                <button
                  onClick={handleExecuteBrief}
                  disabled={loading}
                  className="ml-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
                >
                  {loading ? 'Generating...' : 'Execute Brief'}
                </button>
              </div>
              <div className="flex gap-2 mt-2 text-xs">
                <span className="bg-blue-100 text-blue-800 px-2 py-1 rounded">
                  Regions: {(typeof brief.regions === 'string' ? JSON.parse(brief.regions) : brief.regions).join(', ')}
                </span>
                <span className="bg-green-100 text-green-800 px-2 py-1 rounded">
                  Demographics: {(typeof brief.demographics === 'string' ? JSON.parse(brief.demographics) : brief.demographics).join(', ')}
                </span>
              </div>
            </div>
          </section>
        )}

        {/* Ideas Section */}
        {ideas.length > 0 && (
          <section>
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-2xl font-bold">Creative Ideas</h2>
              <button
                onClick={handleGenerateAllCreatives}
                disabled={loading}
                className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
              >
                {loading && <RefreshCw className="w-4 h-4 animate-spin" />}
                {loading ? 'Generating...' : 'Generate All'}
              </button>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {ideas.map(idea => (
                <IdeaCard 
                  key={idea.id} 
                  idea={idea}
                  onRegenerate={handleRegenerateIdea}
                  onGenerateCreative={handleGenerateCreative}
                  onDelete={handleIdeaDeleted}
                />
              ))}
            </div>
          </section>
        )}

        {/* Approval Queue Section */}
        {creatives.length > 0 ? (
          <section>
            <h2 className="text-2xl font-bold mb-4">Approval Queue ({creatives.length} creatives)</h2>
            <ApprovalQueue creatives={creatives} onCreativeUpdate={fetchCreatives} />
          </section>
        ) : (
          <section>
            <div className="text-center py-8 text-gray-400 border-2 border-dashed rounded-lg">
              No creatives yet. Click "Generate Creative" on an idea to create visual assets.
            </div>
          </section>
        )}
      </div>
    </div>
  );
}
